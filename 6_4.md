### 图的拓扑排序和关键路径

1. 拓扑排序

（1）应用：

    拓扑排序说的是任何事情都是有先后顺序的，做第二件事情之前就要保证第一件已经做过了。就是：有向图；线性序列；全部顶点。

    对于学生选修课程问题：顶点——表示课程；有向弧——表示先决条件，若课程i是j的先决条件，则图中有弧<i,j>。学生应按怎样的顺序学习这些课程，才能无矛盾、顺利地完成学业——拓扑排序。AOV网——用顶点表示活动，用弧表示活动间优先关系的有向图称为顶点表示活动的网(Activity On Vertex network)，简称AOV网。若<vi,vj>是图中有向边，则vi是vj的直接前驱；vj是vi的直接后继；AOV网中不允许有回路，这意味着某项活动以自己为先决条件。拓扑排序——把AOV网络中各顶点按照它们相互之间的优先关系排列成一个线性序列的过程叫拓扑排序。检测AOV网中是否存在环方法：对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则该AOV网必定不存在环。


2. 结构

有向图，先后顺序，使用邻接表最合适的。

增加了一个入度域，一个节点的出度是很容易确定的，但是入度很难确定，所以最好的方式就是在结构中增加这么一个字段，因为以后使用起来方便。

![pic](pic/32.jpg)

```c
//链表节点
typedef struct node
{
	int vex;//邻接点域
	int length;//权值
	struct node *next;//链域
}JD;

//表头结点
typedef struct 
{
	char vexdata;//数据域
	int in;//入度域
	struct node *firstarc;
}TD;
```

3. 图的初始化

```c
//链式图的创建
#define M 9//图的顶点数
#define N 11//图的边数
int creat(TD g[]){
	int i,j;
	JD *p=NULL;
	char ch1,ch2,c;
	int length=0;
	//*****注意：//因为以后要++所以这里要初始值，不初始值无法++，但是要写成count=count+1的形式***********
	//*****所以要养成定义一个变量就给初始值的习惯**********
	int count=0;

	//1.初始化g[i].vexdata
	printf("请输入所有顶点：\n");
	for(i=1;i<=M;i++)
	{
		scanf("%c",&c);
		g[i].vexdata=c;
		g[i].firstarc=NULL;

		//*******之前这里并没有进行初始化，即不管它，只为它开辟了空间***
		//该函数方法最后调用了incount(g);方法，在incount(g)方法中出现了g[k].in++语句，自增语句出现的前提是in已经有一个初始值了，
		//所以这里如果没有给定in初始值，对后面的方法执行是有误的。
		//********所以要记住：初始化时要将任何一个值进行初始化，即使现在可能用不到它，但是保不定以后可能会用到，所以一定要初始化*********
		g[i].in=0;

		//****吃掉回车符*****
		getchar();
	}

	//2.循环输入边，初始化链表节点
	//******这里就显示出count的作用了，作为循环判断的条件******
	while(count!=N)
	{
		printf("输入起点终点和边值：");
		scanf("%c%c%d",&ch1,&ch2,&length);
		//每次输入一个count++
		count++;
		i=local(g,ch1);
		j=local(g,ch2);
		//开辟内存空间
		p=(JD *)malloc(sizeof(JD));
		if(p==NULL)
			return 0;
		p->vex=j;
		p->length=length;

		//******注意对于p->next要分情况******
		if(g[i].firstarc==NULL)//这里少写了一个"="编译器编译运行都没有报错，但是输出结果错了
		{
			p->next=NULL;
		}
		else
		{
			p->next=g[i].firstarc;
		}
		g[i].firstarc=p;
		//*****易漏：吃掉回车****
		getchar();
		
	}

	//初始化in（入度）
	incount(g);
	return 1;
}
```

4. 求每个顶点的入度的算法

遍历TD数组的每个元素的每条链，初始化入度in

```c
//求每个顶点的入度算法
int incount(TD g[])
{
	JD *p;
	int i,k=0;

	//1.循环遍历链表节点
	//注意i的初始值是1
	for(i=1;i<=M;i++)
	{
		p=g[i].firstarc;
		while(p)
		{
			//2.根据得到的链表vex域，进行in++，然后指针继续移动
			k=p->vex;
			
			//出现该语句要提起重视：自增语句的前提是in已经进行了初始化，虽然在本方法中没有进行初始化，但是该方法是被int creat(TD g[])方法
			//调用的，已经给定了初始值in=0，所以这里是安全的。
			g[k].in++;

			p=p->next;
		}
	}
	return 1;
}
```

5. 其余函数

```c
//确定某顶点的下标
int local(TD g[],char u)
{

	//1.用k作为保存下标的辅助空间
	int k,i;

	//2.循环在g[]数组中进行查找
	for(i=1;i<=M;i++)
	{
		if(g[i].vexdata==u){
			k=i;
			//*******注意找到后及时的退出循环，避免占用资源****
			break;
		}
	}
	return k;
}

```
6. 拓扑排序

![pic](pic/33.jpg)

思路：

    循环遍历找到所有入度为0的点入栈
    循环遍历将栈中所有元素的指向的节点的入度减1，入度为0后入栈
    每次出栈的时候统计输出的节点的个数用来做后面的判断
    
    为什么使用栈这个辅助空间呢？
    因为栈的作用就是临时存储的，只是取出来的时候是有规律的，不是乱取出来的

```c
//拓扑排序  AOV网
//看重拓扑排序在实际生活中的意义
//拓扑排序：算法完成后有所有的节点，如果没有环是正确的。案例：(1)学生课程安排及课程学习顺序是有先后的，不可以出现矛盾，不可以出现环
//										        (2)一个工程有很多步骤，这些步骤也是有顺序的，不可以出现环的现象
//拓扑排序即：任何事情都有发生的前提，不可能以自己为前提
int toposort(TD g[])
{   
    SqStack S;
    int m,j,k;
	JD *p=NULL;
	//1.初始化栈
	//拓扑排序需要一个辅助栈
    initSqStack(S);

    m=0;

	//2.入度为0的第一个进栈
    for(j=1;j<=M;j++)
	{
		if(g[j].in==0) 
			//进栈
			push(S,j);
	}

	//3.进入循环
     while(!empty(S))
     {  

		   //4.从栈中取出元素并输出
		   j=pop(S);
		   printf("%c",g[j].vexdata);

		   //5.计数器++,计数器的作用是为了判断循环结束之后是否有剩余的元素
		   m++;

		   //6.从出栈元素的表头开始向链表，所有链表节点的元素（通过指针进行移动）入度in--,当入度为0时进栈.
		   p=g[j].firstarc;
		   while(p!=NULL)
		   {     
			 k=p->vex;
			g[k].in--;
			if(g[k].in==0)
				push(S,k);
			p=p->next;
		   }
    }

   //最后从栈中取出元素后有剩余的情况
   if(m<M)  return 0;
   return  1;
}
```

7. 关键路径

（1）
