### 查找

    查找：
    
    静态查找表，动态查找表。
    静态查找表（只做查找的动作）：顺序表查找，有序表的折半查找，索引顺序表的分块查找，（静态树表的查找）
    动态查找表（查找的时候进行插入删除的动作）：二叉排序树，平衡二叉树，B-/B+树，键树

#### 静态查找表

1. 数据的存储结构不同，查找方式也不同
   
   顺序，链式
   
2. 线性表的顺序存储：顺序表查找，折半查找（前提是数据是有序的且是顺序存储的）

        顺序查找：就是从左到右一个挨一个的查找
        折半查找：就是从中间开始比较

```c
//静态查找
//顺序存储
typedef struct node
{
	int *base;
	int length;
	int size;
}list;
//初始化
void Init(list &L)
{
	int i;
	L.base=(int *)malloc(100*sizeof(int));
	if(!L.base)
		return;
	L.length=0;
	L.size=100;
	for(i=1;i<10;i++)
	{
		L.base[i]=i;
		L.length++;
	}

}
//1.顺序查找
int Find1(list L,int k)
{
	int i;
	for(i=1;i<10;i++)
	{
		if(L.base[i]==k)
			return i;//返回位置
	}
		return -1;
}
//2.折半查找(有序的数组)
int Find2(list L,int k)
{
	int low,high,mid;
	low=1;
	high=L.base[L.length];
	while(high>low)
	{
		mid=(low+high)/2;
		if(L.base[mid]==k)
			return mid;
		if(k>L.base[mid])
			low=mid+1;
		else if(k<L.base[mid])
			high=mid-1;
	}
	return -1;
}

```

平均查找长度ASL:指的是每一个元素查找成功的概率之和

（1）顺序查找（在肯定能查找成功的前提下）：

![pic](pic/36.jpg)

如果也考虑查找失败的情况：

![pic](pic/37.jpg)

假设每一个的查找概率都是1/n,第一个元素的ASL=1*1/n,第二个元素的ASL=2*1/n,.....所以在等概率的情况下顺序表的平均查找长度是ASL=(1/n)*[n*(n+1)/2]=(n+1)/2;

（2）折半查找：

![pic](pic/38.jpg)

折半查找的ASL（性能分析）:

折半查找的查找过程类似于判定树（有序二叉树）：

![pic](pic/39.jpg)

二叉树每层的节点的个数最多是2(j-1)次方，假定每个元素的查找概率都是1/n,第一个元素的ASL=1*1/n*2(1-1)（后边这个括号是次方）
第二个元素ASL=2*1/n*2(2-1)（后边这个括号是次方）：其实就是计算每一个元素的查找长度，求总和。

![pic](pic/40.jpg)

（3）索引顺序表查找（分块查找）：

块内无序，块间有序，索引表上层存的是某块最大的数值，下层存的是该块第一个元素的开始地址。

![pic](pic/41.jpg)

注意：几种查找方式的比较

![pic](pic/42.jpg)


#### 动态查找表

不仅进行查找的动作，还进行插入删除的动作。表的结构是在查找的过程中动态生成的，就是查找K，如果存在返回查找成功，如果不存在，就插进去。
这里的动态查找，使用的存储结构式是：二叉排序树。











1. 树的链式存储结构：

```c
//链式存储
typedef struct node
{
	int vexdata;//数据
	int i;//号
	struct node *lchild,*rchild;//左右孩子指针
}tre,*Tree;
```
2. 二叉排序树的完整操作：

(1)初始化：
```c
//动态查找
#include <stdio.h>
#include <stdlib.h>
#define N 10
//链式存储
typedef struct node
{
	int vexdata;
	int i;//号
	struct node *lchild,*rchild;
}tre,*Tree;
//1.初始化一棵二叉排序树
void InitTree(Tree T,int visit[],int n,int data[])
{
	int i;
	for(i=1;i<=8;i++)
		visit[i]=0;
	T=(int *)malloc(sizeof(int));
	if(!T)
		return ;
	T->vexdata=data[1];
	T->lchild=T->rchild=NULL;
	visit[1]=1;


}
//2.查找
//k是要查找的数据，p是要返回查找到的返回一棵树，f是要查找的树的父亲，查找到了之后，将树存储在f中。
//查找的时候，没查找到，p返回的是NULL，查找到了返回p是指向一棵树的
int Find(Tree T,int k,Tree f,Tree &p)//即使p为指针，任然可以返回给它
{
	if(!T)
	{
		p=f;
		return 0;
	} 
	else if(T->vexdata==k)
	{
		p=T;
		return 1;
	}
	else if(k<T->lchild->vexdata)
	{
		return Find(T->lchild,k,T,p);
	}
	else 
		return Find(T->rchild,k,T,p);

}
//3.插入
int InsertTree(Tree &T,int k,Tree p)
{
	Tree s;
  //插入这个节点之前，先判断这个节点在有序树中是否存在
	if(!Find(T,k,NULL,p))//注意：p指针最后停止的位置
	{
		s=(int *)malloc(sizeof(int));
		if(!s)
			return 0;
		s->vexdata=k;
		s->lchild=s->rchild=NULL;
		if(!T)
			T=s;
		else if(k<p->vexdata)
			p->lchild=s;
		else
			p->rchild=s;
		return 1;
	}
	else 
	 return 0;//没有插入就返回0
}
//4.删除
int Delet(Tree &T,Tree f)
{
	Tree q;
	int j;
	//f->i=(T->i)/2;
	Tree s;
	if(!T->rchild)
	{
		if(T->lchild)
		{
			if(f->lchild==T)
				f->lchild=T->lchild;
			else
				f->rchild=T->lchild;
		}
		else
		{
			if(f->lchild==T)
				f->lchild=NULL;
			else
				f->rchild=NULL;
		}
	}
	else
	{
	
		if(!T->lchild)
		{
			if(f->lchild==T)
				f->lchild=T->rchild;
			else 
				f->rchild=T->rchild;
		}
		else//左右孩子都有
		{
			q=T->lchild;
			while(q->rchild)
			{
				s=q;//新的Q的父类
				q=q->rchild;
				
			}
			T->vexdata=q->vexdata;
			//f->in=(q->in)/2;
			if(q->lchild)
			{
				s->rchild=q->lchild;
			}
			else 
				s->rchild=NULL;
		}
	}

}
//4.删除
int DeletTree(Tree &T,int k,Tree f)
{
	if(!T)
		return 0;
	else if(T->vexdata==k)
		return Delet(T,f);
	else if(T->lchild->vexdata>k)
		return DeletTree(T->lchild,k,T);
	else 
		return DeletTree(T->rchild,k,T);
}
//5.输出
void OutPut(Tree T)
{
	//利用树的中序遍历  从小到大


}
void main()
{
	int visit[N];
	Tree T,p=NULL;
	int k;
	int ret;
	int data[N]={49,38,67,97,76,13,27,50};
	InitTree(T,visit,N,data);
	printf("请输入查找元素：");
	scanf("%d",&k);
	ret=Find(T, k,NULL,p);
	if(ret==1)
	{
		printf("查找成功！");
		return;
	}
	printf("\n插入的结果：");
	InsertTree(T,k,p);
	OutPut(T);
	printf("\n请输入查找元素：");
	scanf("%d",&k);
	ret=Find(T, k,NULL,p);
	if(ret==1)
	{
		printf("查找成功！");
		return;
	}


}
```
